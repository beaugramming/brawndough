pragma solidity ^0.4.23;

import "../tokens/BurnableXcert.sol";
import "./Xcert.sol";

contract Brawndough is BurnableXcert {
    //structs contains all of the minted Brawndough tokens details, and such.
    struct Electrolight {
        address owner;
        uint256 tokenIdentifier;
        string description;
        uint256 cost;
    }
    // Store Electrolight struct
    // Fetch Electrolight
    mapping(uint => Electrolight) public electrolights;
    // Store count of minted Brawndough
    uint256 public brawndoughCount;
    //Initialize array of deletedtokenId to check for deletion otherwise delete
    uint256[] public existingTokenId;

    // Minted, Destroyed, Transfer, claim events
    event brawndoughEvent(address indexed _owner);

    constructor()
    public
    {
        nftName = "Brawndough";
        nftSymbol = "BDH";
        nftConventionId = 0x6be14f75;
    }

    function mintBrawndough(address _owner, string _uri, uint256 _cost)
    public
    {
        brawndoughCount ++;
        existingTokenId.push(brawndoughCount);
        super._mint(_owner, brawndoughCount);
        super._setTokenUri(brawndoughCount, _uri);
        electrolights[brawndoughCount] = Electrolight(_owner, brawndoughCount, _uri, _cost);
        emit brawndoughEvent(_owner);
        return newEntity(brawndoughCount, brawndoughCount);
    }

    function destroyBrawndough(address _owner, uint256 _tokenId)
    public
    {
        require(existingTokenId[_tokenId]>0, "Not a valid tokenID");
        delete existingTokenId[_tokenId];
        super._burn(_owner, _tokenId);
        emit brawndoughEvent(_owner);
        
    }

    // function displayBrawndough()
    // public
    // returns(bytes32) 
    // { 
    //     for (uint i = 0 ; i<=exstingTokenId.length; i++){
    //         return electrolights[existingTokenId[i]];
    //     }
    // }

    // https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity
    //https://medium.com/@robhitchens/solidity-crud-part-2-ed8d8b4f74ec
    function isEntity(unit256 _tokenId) public view returns(bool isIndeed) {
        if(entityList.length == 0) return false;
        return (existingTokenId[electrolights[entityId].tokenIdentifier] == entityId);
    }

    function getEntityCount() public view returns(uint entityCount) {
        return entityId.length;
    }

    function newEntity(uint256 _tokenId, uint256 tokenIdentifier) public returns(bool success) {
        if(isEntity(_tokenId)) revert();
        electrolights[_tokenId].tokenIdentifier = tokenIdentifier;
        electrolights[_tokenId].tokenIdentifier = entityList.push(_tokenId) - 1;
        return true;
    }

    function updateEntity(uint256 _tokenId, uint tokenIdentifier) public returns(bool success) {
        if(!isEntity(existingTokenId)) revert();
        electrolights[existingTokenId].tokenIdentifier = tokenIdentifier;
        return true;
    }

    function deleteEntity(uint256 tokenId) public returns(bool success) {
        if(!isEntity(existingTokenId)) revert();
        uint rowToDelete = electrolights[existingTokenId].listPointer;
        address keyToMove   = entityList[entityList.length-1];
        entityList[rowToDelete] = keyToMove;
        electrolights[keyToMove].listPointer = rowToDelete;
        entityList.length--;
        return true;
    }




    // function transferBrawndough(address _owner, address _to, uint256 _tokenId)
    // public
    // {
    //     super._approve(_to, _tokenId);
    //     super._safeTransferFrom(_owner, _to, _tokenId);
    //     emit brawndoughEvent(_owner);
    // }

}